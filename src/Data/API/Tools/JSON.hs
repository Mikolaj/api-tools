{-# LANGUAGE TemplateHaskell            #-}

module Data.API.Tools.JSON
    ( jsonTool
    , toJsonNodeTool
    , fromJsonNodeTool
    ) where

import           Data.API.JSON
import           Data.API.TH
import           Data.API.Tools.Combinators
import           Data.API.Tools.Datatypes
import           Data.API.Tools.Enum
import           Data.API.Types
import           Data.API.Utils

import           Data.Aeson hiding (withText, withBool)
import           Control.Applicative
import qualified Data.Map                       as Map
import qualified Data.Text                      as T
import           Language.Haskell.TH


-- | Tool to generate 'ToJSON' and 'FromJSONWithErrs' instances for
-- types generated by 'datatypesTool'.  This depends on 'enumTool'.
jsonTool :: APITool
jsonTool = apiNodeTool $ toJsonNodeTool `appendTool` fromJsonNodeTool


-- | Tool to generate 'ToJSON' instance for an API node
toJsonNodeTool :: APINodeTool
toJsonNodeTool = apiSpecTool gen_sn_to gen_sr_to gen_su_to gen_se_to (const emptyTool)
                 `appendTool` gen_pr

-- | Tool to generate 'FromJSONWithErrs' instance for an API node
fromJsonNodeTool :: APINodeTool
fromJsonNodeTool = apiSpecTool gen_sn_fm gen_sr_fm gen_su_fm gen_se_fm (const emptyTool)
                   `appendTool` gen_in


{-
instance ToJSON JobId where
    toJSON = String . _JobId
-}

gen_sn_to :: APINode -> SpecNewtype -> Q [Dec]
gen_sn_to an sn = optionalInstanceD ''ToJSON [nodeRepT an]
                      [simpleD 'toJSON bdy]
  where
    bdy = [e| $ine . $(newtypeProjectionE an) |]

    ine = case snType sn of
            BTstring -> [e| String |]
            BTbinary -> [e| toJSON |]
            BTbool   -> [e| Bool   |]
            BTint    -> [e| mkInt  |]
            BTutc    -> [e| mkUTC  |]


{-
instance FromJSONWithErrs JobId where
    parseJSONWithErrs = withText "JobId" (pure . JobId)
-}

gen_sn_fm :: APINode -> SpecNewtype -> Q [Dec]
gen_sn_fm an sn = optionalInstanceD ''FromJSONWithErrs [nodeRepT an]
                      [simpleD 'parseJSONWithErrs bdy]
  where
    bdy   = [e| $wth $(typeNameE (anName an)) (pure . $(nodeConE an)) |]

    wth   =
        case (snType sn, snFilter sn) of
            (BTstring, Just (FtrStrg re)) -> [e| withRegEx re    |]
            (BTstring, _                ) -> [e| withText        |]
            (BTbinary, _                ) -> [e| withBinary      |]
            (BTbool  , _                ) -> [e| withBool        |]
            (BTint   , Just (FtrIntg ir)) -> [e| withIntRange ir |]
            (BTint   , _                ) -> [e| withInt         |]
            (BTutc   , Just (FtrUTC  ur)) -> [e| withUTCRange ur |]
            (BTutc   , _                ) -> [e| withUTC         |]



{-
instance ToJSON JobSpecId where
     toJSON = \ x ->
        object
            [ "Id"         .= jsiId         x
            , "Input"      .= jsiInput      x
            , "Output"     .= jsiOutput     x
            , "PipelineId" .= jsiPipelineId x
            ]
-}

gen_sr_to :: APINode -> SpecRecord -> Q [Dec]
gen_sr_to an sr = do
    x <- newName "x"
    optionalInstanceD ''ToJSON [nodeRepT an] [simpleD 'toJSON (bdy x)]
  where
    bdy x = lamE [varP x] $
            varE 'object `appE`
            listE [ [e| $(fieldNameE fn) .= $(nodeFieldE an fn) $(varE x) |]
                  | (fn, _) <- srFields sr ]


{-
instance FromJSONWithErrs JobSpecId where
     parseJSONWithErrs (Object v) =
        JobSpecId <$>
            v .: "Id"                               <*>
            v .: "Input"                            <*>
            v .: "Output"                           <*>
            v .: "PipelineId"
     parseJSONWithErrs v          = failWith $ expectedObject val
-}

gen_sr_fm :: APINode -> SpecRecord -> Q [Dec]
gen_sr_fm an sr = do
    x <- newName "x"
    optionalInstanceD ''FromJSONWithErrs [nodeRepT an]
                      [funD 'parseJSONWithErrs [cl x, cl' x]]
  where
    cl   x = clause [conP 'Object [varP x]] (normalB (bdy x)) []
    bdy  x = applicativeE (nodeConE an) [ [e| $(varE x) .:. $(fieldNameE fn) |]
                                        | (fn, _) <- srFields sr ]

    cl'  x = clause [varP x] (normalB (bdy' x)) []
    bdy' x = [e| failWith (expectedObject $(varE x)) |]


{-
instance ToJSON Foo where
    toJSON (Bar x) = object [ "x" .= x ]
    toJSON (Baz x) = object [ "y" .= x ]
-}

gen_su_to :: APINode -> SpecUnion -> Q [Dec]
gen_su_to an su = optionalInstanceD ''ToJSON [nodeRepT an] [funD 'toJSON cls]
  where
    cls      = map (cl . fst) (suFields su)

    cl  fn   = do x <- newName "x"
                  clause [nodeAltConP an fn [varP x]] (bdy fn x) []

    bdy fn x = normalB [e| object [ $(fieldNameE fn) .= $(varE x) ] |]


{-
instance FromJSONWithErrs Foo where
    parseJSONWithErrs (Object v) = alternatives (failWith $ MissingAlt ["x", "y"])
        [ Bar <$> v .:: "x"
        , Baz <$> v .:: "y"
        ]
    parseJSONWithErrs val        = failWith $ expectedObject val
-}

gen_su_fm :: APINode -> SpecUnion -> Q [Dec]
gen_su_fm an su = do
    x <- newName "x"
    optionalInstanceD ''FromJSONWithErrs [nodeRepT an]
                      [funD 'parseJSONWithErrs [cl x, cl' x]]
  where
    cl  x = clause [conP 'Object [varP x]] (normalB (bdy x)) []
    bdy x = [e| alternatives (failWith $ MissingAlt $ss) $(alts x) |]

    alt x fn = [e| fmap $(nodeAltConE an fn) ($(varE x) .:: $(fieldNameE fn)) |]

    alts x = listE $ map (alt x) fns
    ss     = listE $ map fieldNameE fns

    fns  = map fst $ suFields su

    cl'  x = clause [varP x] (normalB (bdy' x)) []
    bdy' x = [e| failWith (expectedObject $(varE x)) |]



{-
instance ToJSON FrameRate where
    toJSON    = String . _text_FrameRate
-}

gen_se_to :: APINode -> SpecEnum -> Q [Dec]
gen_se_to an _se = optionalInstanceD ''ToJSON [nodeRepT an] [simpleD 'toJSON bdy]
  where
    bdy = [e| String . $(varE (text_enum_nm an)) |]


{-
instance FromJSONWithErrs FrameRate where
    parseJSONWithErrs = jsonStrMap_p _map_FrameRate
-}

gen_se_fm :: APINode -> SpecEnum -> Q [Dec]
gen_se_fm an _se = optionalInstanceD ''FromJSONWithErrs [nodeRepT an]
                       [simpleD 'parseJSONWithErrs bdy]
  where
    bdy = [e| jsonStrMap_p $(varE (map_enum_nm an)) |]


gen_in :: APINode -> Q [Dec]
gen_in an = case anConvert an of
  Nothing          -> return []
  Just (inj_fn, _) -> optionalInstanceD ''FromJSONWithErrs [nodeT an]
                          [simpleD 'parseJSONWithErrs bdy]
   where
    bdy = do x <- newName "x"
             lamE [varP x] [e| parseJSONWithErrs $(varE x) >>= $inj |]
    inj = varE $ mkName $ _FieldName inj_fn


gen_pr :: APINode -> Q [Dec]
gen_pr an = case anConvert an of
  Nothing          -> return []
  Just (_, prj_fn) -> optionalInstanceD ''ToJSON [nodeT an] [simpleD 'toJSON bdy]
   where
    bdy = [e| toJSON . $prj |]
    prj = varE $ mkName $ _FieldName prj_fn


alternatives :: Alternative t => t a -> [t a] -> t a
alternatives none = foldr (<|>) none

mkInt :: Int -> Value
mkInt = Number . fromInteger . toInteger


jsonStrMap_p :: Ord a => Map.Map T.Text a -> Value -> ParserWithErrs a
jsonStrMap_p mp = json_string_p (Map.keys mp) $ flip Map.lookup mp

json_string_p :: Ord a => [T.Text] -> (T.Text->Maybe a) -> Value -> ParserWithErrs a
json_string_p xs p (String t) | Just val <- p t = pure val
                              | otherwise       = failWith $ UnexpectedEnumVal xs t
json_string_p _  _ v                            = failWith $ expectedString v


fieldNameE :: FieldName -> ExpQ
fieldNameE = stringE . _FieldName

typeNameE :: TypeName -> ExpQ
typeNameE = stringE . _TypeName
