{-# LANGUAGE DefaultSignatures          #-}
{-# LANGUAGE OverloadedStrings          #-}
{-# LANGUAGE TemplateHaskell            #-}

-- | Tool for generating documentation-friendly examples
module Data.API.Tools.Example
    ( Example(..)
    , exampleTool
    , samplesTool
    ) where

import           Data.API.TH
import           Data.API.Tools.Combinators
import           Data.API.Tools.Datatypes
import           Data.API.Types

import           Control.Applicative
import           Data.Aeson
import qualified Data.ByteString.Char8          as B
import           Data.Time
import           Language.Haskell.TH
import           Safe
import           Test.QuickCheck                as QC
import qualified Data.Text                      as T


-- | The Example class is used to generate a documentation-friendly
-- example for each type in the model

class Example a where
    -- | Generator for example values; defaults to 'arbitrary' if not
    -- specified
    example :: Gen a
    default example :: Arbitrary a => Gen a
    example = arbitrary

instance Example a => Example (Maybe a) where
    example = oneof [return Nothing, Just <$> example]

instance Example a => Example [a] where
    example = listOf example

instance Example Int where
    example = arbitrarySizedBoundedIntegral `suchThat` (> 0)

instance Example Bool where
    example = choose (False, True)

instance Example T.Text where
    example = return "Mary had a little lamb"

instance Example Binary where
    example = return $ Binary $ B.pack "lots of 1s and 0s"

instance Example Value where
    example = return $ String "an example JSON value"

instance Example UTCTime where
    example = return $ fromJustNote dg $ parseUTC_ "2013-06-09T15:52:30Z"
      where
        dg = "Data.API.Tools.Example-UTCTime"


-- | Generate a list of (type name, sample generator) pairs
-- corresponding to each type in the API, with samples encoded as
-- JSON.  This depends on the 'Example' instances generated by
-- 'exampleTool'.  It generates something like this:
--
-- > samples :: [(String, Gen Value)]
-- > samples = [("Foo", fmap toJSON (example :: Gen Foo)), ... ]

samplesTool :: Name -> APITool
samplesTool nm api' = simpleD nm [t| [(String, Gen Value)] |]
                              (listE [ gen_sample nd | ThNode nd <- api' ])
  where
    gen_sample :: APINode -> ExpQ
    gen_sample an = [e| ($str, fmap toJSON (example :: Gen $tc)) |]
      where
        tc  = conT $ type_nm an
        str = stringE $ _TypeName $ anName an


-- | Tool to generate 'Example' instances for types generated by
-- 'datatypesTool'.  This depends on 'quickCheckTool'.
exampleTool :: APITool
exampleTool = apiNodeTool $ apiSpecTool gen_sn_ex gen_sr_ex gen_su_ex gen_se_ex (const emptyTool)


-- | Generate an 'Example' instance for a newtype.  If there is no
-- filter, call 'example' on the underlying type; otherwise, use
-- 'arbitrary'.  Like 'Arbitrary', if a regular expression filter is
-- applied the instance must be defined manually.
gen_sn_ex :: APINode -> SpecNewtype -> Q [Dec]
gen_sn_ex as sn = case snFilter sn of
                               Nothing          -> inst bdy
                               Just (FtrStrg _) -> return []
                               Just _           -> inst $ VarE 'QC.arbitrary
  where
    inst e = mkInstanceIfNotExists ''Example [ConT tn]
                 [FunD 'example [Clause [] (NormalB e) []]]

    bdy  = AppE (AppE (VarE 'fmap) $ ConE $ rep_type_nm as) $
                           VarE 'example

    tn     = rep_type_nm as


-- | Generate an 'Example' instance for a record:
--
-- > instance Example Foo where
-- >     example = sized $ \ x -> Foo (resize (x/2) example) ... (resize (x/2) example)

gen_sr_ex :: APINode -> SpecRecord -> Q [Dec]
gen_sr_ex as sr = mkInstanceIfNotExists ''Example [ConT tn] [FunD 'example [cl]]
  where
    cl    = Clause [] bdy []

    bdy   = NormalB $ AppE (VarE 'QC.sized) $ LamE [VarP x_nm] $
                app (ConE tn) $
                replicate (length $ srFields sr) $
                VarE 'QC.resize
                         `AppE` (VarE 'div `AppE` VarE x_nm `AppE` LitE (IntegerL 2))
                         `AppE` VarE 'example

    tn    = rep_type_nm as


-- | Generate an 'Example' instance for a union:
--
-- > instance Example Foo where
-- >     example = oneOf [ fmap Bar example, fmap Baz example ]

gen_su_ex :: APINode -> SpecUnion -> Q [Dec]
gen_su_ex as su = mkInstanceIfNotExists ''Example [ConT tn] [FunD 'example [cl]]
  where
    cl  = Clause [] bdy []

    bdy = NormalB $ if null ks then emp else prp

    emp = ConE tn

    prp = AppE (VarE 'oneof) $
                ListE [ VarE 'fmap `AppE` ConE k `AppE` VarE 'example | k<- ks ]

    tn    = rep_type_nm as

    ks  = map (pref_con_nm as) $ map fst $ suFields su


-- | Generate an 'Example' instance for an enumeration, with no
-- definition for the 'example' method, because we can inherit the
-- behaviour of 'Arbitrary':
--
-- > instance Example Foo

gen_se_ex :: APINode -> SpecEnum -> Q [Dec]
gen_se_ex as _ = mkInstanceIfNotExists ''Example [ConT tn] []
  where
    tn    = rep_type_nm as
