{-# LANGUAGE OverloadedStrings          #-}
{-# LANGUAGE TemplateHaskell            #-}

-- | This module provides an interface for generating TH declarations
-- from an 'API'.  To use it, splice in a call to 'generate' followed
-- by one or more calls to 'generateAPITools', like so:
--
-- > $(generate myAPI)
-- > $(generateAPITools [enumTool, jsonTool, quickCheckTool] myAPI)
--
-- If you wish to override any of the instances generated by the
-- tools, you can do so by writing instance declarations after the
-- call to 'generate' but before the call to 'generateAPITools'.

module Data.API.Tools
    ( generate
    , generateAPITools

    , generateInstances
    , generateTools
    , generateSamples
    , generateTests
    , generateMigrationKinds

      -- * Individual tools
    , enumTool
    , exampleTool
    , jsonTool
    , jsonTestsTool
    , lensTool
    , quickCheckTool
    , safeCopyTool
    , samplesTool
    ) where

import           Data.API.Tools.Combinators
import           Data.API.Tools.Datatypes
import           Data.API.Tools.Enum
import           Data.API.Tools.Example
import           Data.API.Tools.JSON
import           Data.API.Tools.JSONTests
import           Data.API.Tools.Lens
import           Data.API.Tools.QuickCheck
import           Data.API.Tools.SafeCopy
import           Data.API.Types
import           Data.API.Changes
import           Control.Applicative
import qualified Data.Set                       as Set
import           Language.Haskell.TH


-- | Generate the datatypes corresponding to an API.
generate :: API -> Q [Dec]
generate = generateAPITools [datatypesTool]

-- | Apply a list of tools to an 'API', generating TH declarations.
-- See the individual tool descriptions for details.  Note that
-- 'generate' must be called first, and some tools have dependencies,
-- which must be included in the same or a preceding call to
-- 'generateAPITools'.
generateAPITools :: [APITool] -> API -> Q [Dec]
generateAPITools tools api = concat <$> mapM ($ api) tools



generateInstances :: API -> Q [Dec]
generateInstances = generateAPITools [enumTool, jsonTool, quickCheckTool]

generateTools :: API -> Q [Dec]
generateTools = generateAPITools [lensTool, safeCopyTool]

generateSamples :: API -> String -> Q [Dec]
generateSamples api nm_s = generateAPITools [exampleTool, samplesTool (mkName nm_s)] api

generateTests :: API -> String -> Q [Dec]
generateTests api nm_s = generateAPITools [jsonTestsTool (mkName nm_s)] api


-- | Generate enumeration datatypes corresponding to the custom
-- migrations used in an API migration changelog.
generateMigrationKinds :: APIChangelog -> String -> String -> String -> Q [Dec]
generateMigrationKinds changes all_nm rec_nm fld_nm = do
    guardNoDups (all_tags `Set.intersection` rec_tags)
    guardNoDups (all_tags `Set.intersection` fld_tags)
    guardNoDups (rec_tags `Set.intersection` fld_tags)

    return [ DataD [] (mkName all_nm) [] (cons all_nm all_tags) derivs
           , DataD [] (mkName rec_nm) [] (cons rec_nm rec_tags) derivs
           , DataD [] (mkName fld_nm) [] (cons fld_nm fld_tags) derivs ]
  where
    (all_tags, rec_tags, fld_tags) = changelogTags changes

    guardNoDups xs
      | Set.null xs = return ()
      | otherwise   = fail $ "generateMigrationKinds: duplicate custom migrations in changelog: "
                             ++ show (Set.toList xs)

    -- List of constructors must not be empty, otherwise GHC can't
    -- derive Read/Show instances (see GHC Trac #7401)
    cons s xs | not (Set.null xs) = map (\ x -> NormalC (mkName x) []) (Set.toList xs)
              | otherwise         = [NormalC (mkName $ "No" ++ s) []]

    derivs = [''Read, ''Show]
